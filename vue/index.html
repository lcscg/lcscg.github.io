<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 面试题 | 前端面试之路</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/images/logo.jpg">
    <meta name="description" content="一些前端面试题，自我提升！">
    
    <link rel="preload" href="/assets/css/0.styles.3bb03b6d.css" as="style"><link rel="preload" href="/assets/js/app.185ea609.js" as="script"><link rel="preload" href="/assets/js/2.c6bbd5b6.js" as="script"><link rel="preload" href="/assets/js/14.e107ffde.js" as="script"><link rel="prefetch" href="/assets/js/10.4ab3fc90.js"><link rel="prefetch" href="/assets/js/11.2beafd29.js"><link rel="prefetch" href="/assets/js/12.924bca3f.js"><link rel="prefetch" href="/assets/js/13.4916f82b.js"><link rel="prefetch" href="/assets/js/3.68e5f779.js"><link rel="prefetch" href="/assets/js/4.5024ae31.js"><link rel="prefetch" href="/assets/js/5.3645d50e.js"><link rel="prefetch" href="/assets/js/6.00972e12.js"><link rel="prefetch" href="/assets/js/7.de709caf.js"><link rel="prefetch" href="/assets/js/8.5fa46af6.js"><link rel="prefetch" href="/assets/js/9.8a962e39.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3bb03b6d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端面试之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  前端面试
</a></div><div class="nav-item"><a href="https://lcscg.github.io/resume/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人简历
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  前端面试
</a></div><div class="nav-item"><a href="https://lcscg.github.io/resume/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人简历
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vue/" aria-current="page" class="active sidebar-link">Vue面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/#mvc和mvvm的区别" class="sidebar-link">mvc和mvvm的区别</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-中-route-和-router-有什么区别" class="sidebar-link">vue 中 $route 和 $router 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/vue/#说说你对-spa-单页面的理解-它的优缺点分别是什么" class="sidebar-link">说说你对 SPA 单页面的理解，它的优缺点分别是什么？</a></li><li class="sidebar-sub-header"><a href="/vue/#为什么-data-是一个函数" class="sidebar-link">为什么 data 是一个函数</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-组件通讯有哪几种方式" class="sidebar-link">Vue 组件通讯有哪几种方式</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-的生命周期方法有哪些" class="sidebar-link">Vue 的生命周期方法有哪些</a></li><li class="sidebar-sub-header"><a href="/vue/#在哪个生命周期内调用异步请求" class="sidebar-link">在哪个生命周期内调用异步请求？</a></li><li class="sidebar-sub-header"><a href="/vue/#父组件可以监听到子组件的生命周期吗" class="sidebar-link">父组件可以监听到子组件的生命周期吗？</a></li><li class="sidebar-sub-header"><a href="/vue/#v-if-和-v-show-的区别" class="sidebar-link">v-if 和 v-show 的区别</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-有那些内置指令" class="sidebar-link">vue 有那些内置指令</a></li><li class="sidebar-sub-header"><a href="/vue/#怎样理解-vue-的单向数据流" class="sidebar-link">怎样理解 Vue 的单向数据流</a></li><li class="sidebar-sub-header"><a href="/vue/#computed-和-watch-的区别和运用的场景" class="sidebar-link">computed 和 watch 的区别和运用的场景</a></li><li class="sidebar-sub-header"><a href="/vue/#谈谈你对-keep-alive-的了解-详解" class="sidebar-link">谈谈你对 keep-alive 的了解？ (详解)</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-中-v-html-会导致什么问题" class="sidebar-link">Vue 中 v-html 会导致什么问题</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-router-路由模式有几种" class="sidebar-link">vue-router 路由模式有几种？</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-修饰符" class="sidebar-link">vue 修饰符</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-实现数据双向绑定的原理" class="sidebar-link">Vue 实现数据双向绑定的原理</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-如何检测数组变化" class="sidebar-link">Vue 如何检测数组变化</a></li><li class="sidebar-sub-header"><a href="/vue/#说说对-v-model-的了解" class="sidebar-link">说说对 v-model 的了解？</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-router-路由钩子函数是什么-执行顺序是什么" class="sidebar-link">vue-router 路由钩子函数是什么 执行顺序是什么</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-router-实现懒加载" class="sidebar-link">vue-router 实现懒加载</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-中-nexttick-作用与原理" class="sidebar-link">vue 中 $nextTick 作用与原理</a></li><li class="sidebar-sub-header"><a href="/vue/#谈一下对-vuex-的理解-详解" class="sidebar-link">谈一下对 vuex 的理解 (详解)</a></li><li class="sidebar-sub-header"><a href="/vue/#vue2-x的diff算法说一下" class="sidebar-link">Vue2.x的diff算法说⼀下</a></li><li class="sidebar-sub-header"><a href="/vue/#vue首屏白屏如何解决" class="sidebar-link">vue首屏白屏如何解决？</a></li><li class="sidebar-sub-header"><a href="/vue/#vm-set-的实现原理" class="sidebar-link">vm.$set() 的实现原理</a></li><li class="sidebar-sub-header"><a href="/vue/#vue-项目优化" class="sidebar-link">Vue 项目优化</a></li></ul></li><li><a href="/javascript/" class="sidebar-link">JavaScript面试题</a></li><li><a href="/css/" class="sidebar-link">CSS面试题</a></li><li><a href="/browser/" class="sidebar-link">浏览器相关</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-面试题"><a href="#vue-面试题" class="header-anchor">#</a> vue 面试题</h1> <h2 id="mvc和mvvm的区别"><a href="#mvc和mvvm的区别" class="header-anchor">#</a> mvc和mvvm的区别</h2> <details><summary>参考</summary> <p>MVC: MVC是应用最广泛的软件架构之一,一般MVC分为:Model(模型),View(视图),Controller(控制器)。 这主要是基于分层的目的,让彼此的职责分开.View一般用过Controller来和Model进行联系。Controller是Model和View的协调者,View和Model不直接联系。基本都是单向联系。</p> <p>MVVM:MVVM是把MVC中的Controller改变成了ViewModel。View的变化会自动更新到ViewModel,ViewModel的变化也会自动同步到View上显示,通过数据来显示视图层。</p> <p>MVVM和MVC的区别:</p> <p>MVC中Controller演变成MVVM中的ViewModel
MVVM通过数据来显示视图层而不是节点操作
MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,加载速度变慢,影响用户体验
</p></details><p></p> <h2 id="vue-中-route-和-router-有什么区别"><a href="#vue-中-route-和-router-有什么区别" class="header-anchor">#</a> vue 中 $route 和 $router 有什么区别？</h2> <details><summary>参考</summary>
$router是 router 实例，通过 this.$router 访问路由器,相当于获取了整个路由文件，在$router.option.routes中，或查看到当前项目的整个路由结构 具有实例方法
<p>$route是当前激活的路由信息对象。这个属性是只读的，里面的属性是 immutable (不可变) 的，不过可以 watch (监测变化) 它。
通过 this.$route 访问的是当前路由，获取和当前路由有关的信息</p></details> <h2 id="说说你对-spa-单页面的理解-它的优缺点分别是什么"><a href="#说说你对-spa-单页面的理解-它的优缺点分别是什么" class="header-anchor">#</a> 说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h2> <details><summary>参考</summary>
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
<p><strong>优点：</strong></p> <ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li> <li>基于上面一点，SPA 相对对服务器压力小；</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul> <p><strong>缺点：</strong></p> <ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li> <li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul></details> <h2 id="为什么-data-是一个函数"><a href="#为什么-data-是一个函数" class="header-anchor">#</a> 为什么 data 是一个函数</h2> <details><summary>参考</summary> <p>组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果</p></details> <h2 id="vue-组件通讯有哪几种方式"><a href="#vue-组件通讯有哪几种方式" class="header-anchor">#</a> Vue 组件通讯有哪几种方式</h2> <details><summary>参考</summary> <ol><li><p>props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的</p></li> <li><p>$parent,$children 获取当前组件的父组件和当前组件的子组件</p></li> <li><p>$attrs 和$listeners A-&gt;B-&gt;C。Vue 2.4 开始提供了$attrs 和$listeners 来解决这个问题</p></li> <li><p>父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)</p></li> <li><p>$refs 获取组件实例</p></li> <li><p>eventBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式</p></li> <li><p>vuex 状态管理</p></li></ol></details> <h2 id="vue-的生命周期方法有哪些"><a href="#vue-的生命周期方法有哪些" class="header-anchor">#</a> Vue 的生命周期方法有哪些</h2> <details><summary>参考</summary> <ul><li><p><strong>beforeCreate</strong> 阶段：beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问</p></li> <li><p><strong>created</strong> 阶段:实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom</p></li> <li><p><strong>beforeMount</strong> 阶段：在挂载开始之前被调用：相关的 render 函数首次被调用。</p></li> <li><p><strong>mounted</strong> 阶段：在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点</p></li> <li><p><strong>beforeUpdate</strong> 阶段：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p></li> <li><p><strong>updated</strong> 阶段：发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。</p></li> <li><p><strong>beforeDestroy</strong> 阶段：实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。</p></li> <li><p><strong>destroyed</strong> 阶段：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p></li> <li><p><strong>activated</strong> : keep-alive 专属，组件被激活时调用</p></li> <li><p><strong>deactivated</strong> : keep-alive 专属，组件被销毁时调用</p></li></ul> <p><img src="/images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=" 生命周期图示"></p></details> <h2 id="在哪个生命周期内调用异步请求"><a href="#在哪个生命周期内调用异步请求" class="header-anchor">#</a> 在哪个生命周期内调用异步请求？</h2> <details><summary>参考</summary> <p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p> <blockquote><p>如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p></blockquote> <ul><li>能更快获取到服务端数据，减少页面  loading 时间；</li> <li>ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul></details> <h2 id="父组件可以监听到子组件的生命周期吗"><a href="#父组件可以监听到子组件的生命周期吗" class="header-anchor">#</a> 父组件可以监听到子组件的生命周期吗？</h2> <details><summary>参考</summary> <p>可以通过@hook 来监听生命周期事件，用法如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//  Parent.vue</span>
<span class="token operator">&lt;</span>Child @hook<span class="token operator">:</span>mounted<span class="token operator">=</span><span class="token string">&quot;doSomething&quot;</span> <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>

<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'父组件监听到 mounted 钩子函数 ...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>

<span class="token comment">//  Child.vue</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'子组件触发 mounted 钩子函数 ...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>

<span class="token comment">// 以上输出顺序为：</span>
<span class="token comment">// 子组件触发 mounted 钩子函数 ...</span>
<span class="token comment">// 父组件监听到 mounted 钩子函数 ...</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></details> <h2 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="header-anchor">#</a> v-if 和 v-show 的区别</h2> <details><summary>参考</summary> <p>v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。</p> <p>v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none）</p> <h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h3> <p>v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景</p> <p>v-show 适用于需要非常频繁切换条件的场景</p></details> <h2 id="vue-有那些内置指令"><a href="#vue-有那些内置指令" class="header-anchor">#</a> vue 有那些内置指令</h2> <details><summary>参考</summary> <table><tr><td>指令</td><td>作用</td></tr> <tr><td> v-once</td><td> 定义它的元素或组件只渲染一次，包括元素或组件的所有子节点。<br>首次渲染后不再随数据的变化重新渲染，将被视为静态内容 </td></tr> <tr><td> v-click</td><td> 这个指令保持在元素上直到关联实例结束编译--解决初始化慢导致页面闪动的最佳实践 </td></tr> <tr><td> v-bind</td><td> 绑定属性，动态更新HTML元素上的属性例如v-bind:class，简写:</td></tr> <tr><td> v-on</td><td> 用于监听DOM事件例如v-on:click v-on:keyup，简写@</td></tr> <tr><td> v-html</td><td> 赋值就是变量innerHTML--注意防止xss攻击</td></tr> <tr><td> v-text</td><td> 更新元素的textContent</td></tr> <tr><td> v-model</td><td> 变成value和input的语法糖  </td></tr> <tr><td> v-if / v-else-if / v-else </td><td> 可以配合template来使用<br>在render函数里面就是三元表达式</td></tr> <tr><td> v-show</td><td> 使用指令来实现--最终会通过display来进行显隐</td></tr> <tr><td> v-pre</td><td> 跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度 </td></tr> <tr><td> v-for</td><td> 循环指令<br>优先级比v-if高最好不要一起使用——尽量使用计算属性去解决<br>注意增加唯一key值——不要使用index作为key</td></tr></table></details> <h2 id="怎样理解-vue-的单向数据流"><a href="#怎样理解-vue-的单向数据流" class="header-anchor">#</a> 怎样理解 Vue 的单向数据流</h2> <details><summary>参考</summary>
数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
<div class="custom-block tip"><p class="custom-block-title">提示</p> <p>注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告
如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改</p></div></details> <h2 id="computed-和-watch-的区别和运用的场景"><a href="#computed-和-watch-的区别和运用的场景" class="header-anchor">#</a> computed 和 watch 的区别和运用的场景</h2> <details><summary>参考</summary> <p><strong>computed</strong>： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p> <p><strong>watch</strong>：更多的是「观察」的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作；</p> <p><strong>运用场景</strong>：</p> <p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用  watch  选项允许我们执行异步操作(访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p></div></details> <h2 id="谈谈你对-keep-alive-的了解-详解"><a href="#谈谈你对-keep-alive-的了解-详解" class="header-anchor">#</a> 谈谈你对 keep-alive 的了解？ (<a href="https://www.jianshu.com/p/a97b623dde98" target="_blank" rel="noopener noreferrer">详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</h2> <details><summary>参考</summary> <p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：
一般结合路由和动态组件一起使用，用于缓存组件</p> <p>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</p> <p>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p></details> <h2 id="vue-中-v-html-会导致什么问题"><a href="#vue-中-v-html-会导致什么问题" class="header-anchor">#</a> Vue 中 v-html 会导致什么问题</h2> <p>在⽹站上动态渲染任意 HTML，很容易导致 XSS 攻击。所以只能在可信内容上使⽤ v-html，且永远不
能⽤于⽤户提交的内容上。</p> <h2 id="vue-router-路由模式有几种"><a href="#vue-router-路由模式有几种" class="header-anchor">#</a> vue-router 路由模式有几种？</h2> <details><summary>参考</summary> <p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">'history'</span><span class="token operator">:</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTML5History</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
  <span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'hash'</span><span class="token operator">:</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallback<span class="token punctuation">)</span>
  <span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'abstract'</span><span class="token operator">:</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbstractHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
  <span class="token keyword">break</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">invalid mode: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li><p>hash:# 后⾯ hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新⻚⾯。同时通过监听 hashchange 事件可以知道 hash 发⽣了哪些变化，然后根据 hash 变化来实现更新⻚⾯部分内容的操作。。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</p></li> <li><p>history : history 模式的实现，主要是HTML5标准发布的两个API， pushState 和 replaceState ，这两个 API 可以在改变url，但是不会发送请求。这样就可以监听 url 变化来实现更新⻚⾯部分内容的操作。</p></li> <li><p>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p></li></ul></details> <h2 id="vue-修饰符"><a href="#vue-修饰符" class="header-anchor">#</a> vue 修饰符</h2> <p><a href="https://juejin.cn/post/6981628129089421326" target="_blank" rel="noopener noreferrer">详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="vue-实现数据双向绑定的原理"><a href="#vue-实现数据双向绑定的原理" class="header-anchor">#</a> Vue 实现数据双向绑定的原理</h2> <details><summary>参考</summary>
Vue 的响应式是通过 Object.defineProperty 对数据进⾏劫持，并结合观察者模式实现。 Vue 利⽤Object.defineProperty 创建⼀个 observe 来劫持监听所有的属性，把这些属性全部转为 getter和 setter 。Vue 中每个组件实例都会对应⼀个 watcher 实例，它会在组件渲染的过程中把使⽤过的数据属性通过 getter 收集为依赖。之后当依赖项的 setter 触发时，会通知 watcher ，从⽽使它关联的组件重新渲染。
</details> <h2 id="vue-如何检测数组变化"><a href="#vue-如何检测数组变化" class="header-anchor">#</a> Vue 如何检测数组变化</h2> <details><summary>参考</summary>
数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对 7 种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写。
所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新
</details> <h2 id="说说对-v-model-的了解"><a href="#说说对-v-model-的了解" class="header-anchor">#</a> 说说对 v-model 的了解？</h2> <details><summary>参考</summary>
v-model 本质就是一个语法糖。
v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
<ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li> <li>checkbox 和 radio 使用 checked 属性和 change 事件；</li> <li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul> <p><strong>以 input 表单元素为例：</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">'something'</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="相当于"><a href="#相当于" class="header-anchor">#</a> 相当于</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;something&quot;</span> v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;something = $event.target.value&quot;</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="父组件"><a href="#父组件" class="header-anchor">#</a> 父组件</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>Child v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;message&quot;</span> @input<span class="token operator">=</span><span class="token string">&quot;$emit('input', $event.target.value)&quot;</span> <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="子组件"><a href="#子组件" class="header-anchor">#</a> 子组件</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> String
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></details> <h2 id="vue-router-路由钩子函数是什么-执行顺序是什么"><a href="#vue-router-路由钩子函数是什么-执行顺序是什么" class="header-anchor">#</a> vue-router 路由钩子函数是什么 执行顺序是什么</h2> <details><summary>参考</summary>
路由钩子的执行流程, 钩子函数种类有:全局守卫、路由守卫、组件守卫
<p>1、全局导航钩子</p> <ul><li>router.beforeEach(to, from, next): 路由改变前的钩子</li> <li>router.beforeResolve: 在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，该钩子函数就被调用</li> <li>router.afterEach: 路由改变后的钩子</li></ul> <p>2、路由独享钩子
可以在路由配置上直接定义 beforeEnter</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>cont router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
   <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
       <span class="token punctuation">{</span>
           <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/file'</span><span class="token punctuation">,</span>
           <span class="token literal-property property">component</span><span class="token operator">:</span> File<span class="token punctuation">,</span>
           <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from <span class="token punctuation">,</span>next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
               <span class="token comment">// do someting</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>3、组件内的导航钩子</p> <ul><li>beforeRouteEnter 在进入当前组件对应的路由前调用</li> <li>beforeRouteUpdate 在当前路由改变，但是该组件被复用时调用</li> <li>beforeRouteLeave 在离开当前组件对应的路由前调用</li></ul> <p><strong>完整的导航解析流程:</strong></p> <ol><li>导航被触发。</li> <li>在失活的组件里调用 beforeRouteLeave 守卫。</li> <li>调用全局的 beforeEach 守卫。</li> <li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li> <li>在路由配置里调用 beforeEnter。</li> <li>解析异步路由组件。</li> <li>在被激活的组件里调用 beforeRouteEnter。</li> <li>调用全局的 beforeResolve 守卫 (2.5+)。</li> <li>导航被确认。</li> <li>调用全局的 afterEach 钩子。</li> <li>触发 DOM 更新。</li> <li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol></details> <h2 id="vue-router-实现懒加载"><a href="#vue-router-实现懒加载" class="header-anchor">#</a> vue-router 实现懒加载</h2> <details><summary>参考</summary> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>路由懒加载做了什么事情？</p> <p>1：主要作用是将路由对应的组件打包成一个个的js代码块</p> <p>2：只有在这个路由被访问到的时候，才加载对应的组件，否则不加载！</p> <p>即：只有在这个路由被访问到的时候，才加载对应的组件，否则不加载！</p></div> <p><strong>如何实现路由懒加载？？</strong>
vue项目实现路由按需加载（路由懒加载）的三种方式</p> <p>1、Vue异步组件</p> <ol><li>vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。</li> <li>component: resolve =&gt; require(['放入需要加载的路由地址'], resolve)</li></ol> <p>2、ES6标准语法import（）---------推荐使用！！！！！</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token punctuation">;</span>
<span class="token comment">// 官网可知：下面没有指定webpackChunkName，每个组件打包成一个js文件。</span>
<span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'../components/Foo'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">Aoo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'../components/Aoo'</span><span class="token punctuation">)</span>
<span class="token comment">// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。</span>
<span class="token comment">// const Foo = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/Foo')</span>
<span class="token comment">// const Aoo = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/Aoo')</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
   <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/Foo'</span><span class="token punctuation">,</span>
   <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Foo'</span><span class="token punctuation">,</span>
   <span class="token literal-property property">component</span><span class="token operator">:</span> Foo
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
   <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/Aoo'</span><span class="token punctuation">,</span>
   <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Aoo'</span><span class="token punctuation">,</span>
   <span class="token literal-property property">component</span><span class="token operator">:</span> Aoo
  <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>3、webpack的require.ensure()</p> <ol><li>vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。</li> <li>这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</li> <li>require.ensure可实现按需加载资源，包括js,css等。他会给里面require的文件单独打包，不会和主文件打包在一起。</li> <li>第一个参数是数组，表明第二个参数里需要依赖的模块，这些会提前加载。</li> <li>第二个是回调函数,在这个回调函数里面require的文件会被单独打包成一个chunk,不会和主文件打包在一起，这样就生成了两个chunk,第一次加载时只加载主文件。</li> <li>第三个参数是错误回调。</li> <li>第四个参数是单独打包的chunk的文件名</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">HelloWorld</span><span class="token operator">=</span><span class="token parameter">resolve</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'@/components/HelloWorld'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/HelloWorld'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'Router'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">routes</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'./'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'HelloWorld'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">component</span><span class="token operator">:</span>HelloWorld
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></details> <h2 id="vue-中-nexttick-作用与原理"><a href="#vue-中-nexttick-作用与原理" class="header-anchor">#</a> vue 中 $nextTick 作用与原理</h2> <details><summary>参考</summary>
作用：是为了可以获取更新后的DOM 。
<p>由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 Vue.nextTick()，就是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。</p> <p>原理：
在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p> <ul><li>Promise</li> <li>MutationObserver</li> <li>setImmediate</li> <li>如果以上都不行则采用setTimeout</li></ul> <p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。
</p></details><p></p> <h2 id="谈一下对-vuex-的理解-详解"><a href="#谈一下对-vuex-的理解-详解" class="header-anchor">#</a> 谈一下对 vuex 的理解 (<a href="https://www.jianshu.com/p/86053b2f8fc1" target="_blank" rel="noopener noreferrer">详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</h2> <details><summary>参考</summary> <p>vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部核心原理是通过创造一个全局实例 new Vue）</p> <p>主要包括以下几个模块：</p> <ul><li>state: 定义了应用状态的数据结构，可以在这里设置默认的初始状态，数据是响应式的</li> <li>getter: 允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性</li> <li>mutations: 定义的方法动态修改 state 中的数据，通过 commit 提交方法，方法必须是同步的</li> <li>actions: 用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li> <li>modules：模块化 vuex,允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul></details> <h2 id="vue2-x的diff算法说一下"><a href="#vue2-x的diff算法说一下" class="header-anchor">#</a> Vue2.x的diff算法说⼀下</h2> <details><summary>参考</summary>
简单来说，diff算法有以下过程
<ul><li>同级⽐较，再⽐较⼦节点</li> <li>先判断⼀⽅有⼦节点⼀⽅没有⼦节点的情况(如果新的children没有⼦节点，将旧的⼦节点移除)</li> <li>⽐较都有⼦节点的情况(核⼼diff)</li> <li>递归⽐较⼦节点</li></ul> <p>正常Diff两个树的时间复杂度是 O(n^3) ，但实际情况下我们很少会进⾏ 跨层级的移动DOM ，所以Vue将
Diff进⾏了优化，从 O(n^3) -&gt; O(n) ，只有当新旧children都为多个⼦节点时才需要⽤核⼼的Diff算法
进⾏同层级⽐较。
Vue2的核⼼Diff算法采⽤了 双端⽐较 的算法，同时从新旧children的两端开始进⾏⽐较，借助key值找
到可复⽤的节点，再进⾏相关操作。相⽐React的Diff算法，同样情况下可以减少移动节点次数，减少不
必要的性能损耗，更加的优雅。</p> <p><a href="https://juejin.cn/post/6994959998283907102" target="_blank" rel="noopener noreferrer">详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></details> <h2 id="vue首屏白屏如何解决"><a href="#vue首屏白屏如何解决" class="header-anchor">#</a> vue首屏白屏如何解决？</h2> <details><summary>参考</summary> <ul><li>路由懒加载</li> <li>vue-cli开启打包压缩和后台配合gzip访问</li> <li>进行cdn加速</li> <li>开启vue服务渲染模式</li> <li>用webpack的externals属性把不需要打包的库文件分离出去，减少打包后文件的大小</li> <li>在生产环境中删除掉不必要的console.log</li></ul></details> <h2 id="vm-set-的实现原理"><a href="#vm-set-的实现原理" class="header-anchor">#</a> vm.$set() 的实现原理</h2> <details><summary>参考</summary> <ol><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li> <li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，</li> <li>最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理</li></ol></details> <h2 id="vue-项目优化"><a href="#vue-项目优化" class="header-anchor">#</a> Vue 项目优化</h2> <details><summary>参考</summary> <p><strong>1.代码层面的优化.</strong></p> <ul><li>v-if 和 v-show 区分使用场景</li> <li>computed 和 watch 区分使用场景</li> <li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li> <li>不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）</li> <li>SPA ⻚⾯采⽤keep-alive缓存组件</li> <li>对象层级不要过深，否则性能就会差</li> <li>防止内部泄漏，组件销毁后把全局变量和事件销毁</li> <li>图片资源懒加载</li> <li>使⽤路由懒加载、异步组件</li> <li>⻓列表滚动到可视区域动态加载</li> <li>第三方插件的按需引入</li> <li>适当采用 keep-alive 缓存组件</li> <li>防抖、节流运用</li> <li>服务端渲染 SSR or 预渲染</li></ul> <p><strong>2.Webpack 层面的优化.</strong></p> <ul><li>Webpack 对图片进行压缩</li> <li>减少 ES6 转为 ES5 的冗余代码</li> <li>提取公共代码</li> <li>模板预编译</li> <li>提取组件的 CSS</li> <li>优化 SourceMap</li> <li>构建结果输出分析</li> <li>Vue 项目的编译优化</li></ul> <p><strong>3.基础的 Web 技术的优化.</strong></p> <ul><li>开启 gzip 压缩</li> <li>浏览器缓存</li> <li>CDN 的使用</li> <li>使用 Chrome Performance 查找性能瓶颈</li></ul></details></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/javascript/">
        JavaScript面试题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.185ea609.js" defer></script><script src="/assets/js/2.c6bbd5b6.js" defer></script><script src="/assets/js/14.e107ffde.js" defer></script>
  </body>
</html>
